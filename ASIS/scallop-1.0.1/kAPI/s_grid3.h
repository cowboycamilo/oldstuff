/* *** This file is automatically generated by dimensions.sh from a ***
   *** dimension-independent file.  Edit at your peril.             *** */


#ifndef _s_grid3_h
#define _s_grid3_h

/*

s_grid is a single processor/serial grid, an extension of the standard
KeLP Grid, with the kinds of extras I use a lot

*/

#include "config.h"
#include "Grid3.h"

#define DIM3D

class f_region3 {
 public:
#if defined(DIM2D)
    int l0, l1, u0, u1;
    f_region2(const Region2& r): l0(r.lower(0)), l1(r.lower(1)),
	u0(r.upper(0)), u1(r.upper(1)) {}
#elif defined(DIM3D)
    int l0, l1, l2, u0, u1, u2;
    f_region3(const Region3& r): l0(r.lower(0)), l1(r.lower(1)),
	l2(r.lower(2)), u0(r.upper(0)), u1(r.upper(1)), u2(r.upper(2)) {}
#else
#error Only 2D and 3D s_grids are defined.
#endif
};    
 
class s_grid3: public Grid3<double> {
 public:
    f_region3 domain;

#if defined(DIM2D)
    s_grid2() : Grid2<double>(), domain(Region2(0, 0, 0, 0)) {}
#elif defined(DIM3D)
    s_grid3() : Grid3<double>(), domain(Region3(0, 0, 0, 0, 0, 0)) {}
#else
#error Only 2D and 3D s_grids are defined.
#endif

    s_grid3(const Region3& region, const int processor) 
	: Grid3<double>(region, processor), domain(region) { 
	cout << region.upper(1) << endl;
    }

    void resize(const Region3& R, const int alloc=TRUE) {
	Grid3<double>::resize(R, alloc);
	domain = f_region3(R);
    }
    void fill(const double val, const Region3& R);
    void fill(const double val) {fill(val,this->region());	}
   void negate();
   void mult(double s);
   double norm(const int p);
};

inline void DefaultPack(s_grid3& G, const Region3& R, double *buf) {  
    G.PackRegion(buf,R);
}

inline void DefaultUnpack(s_grid3& G, const Region3& R, double *buf) {
    G.UnPackRegion(buf,R);
}

inline void DefaultCopy(s_grid3& FG, const Region3& FR, 
			s_grid3& TG, const Region3& TR) {
    TG.CopyRegion(TR,FG,FR);
}

#endif
