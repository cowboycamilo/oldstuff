PROGRAM CHRIS(INPUT,OUTPUT,TAPEIN,TAPEOUT,MINI);
(* DEFINES SECONDARY STRUCTURE AND SOLVENT EXPOSURE OF PROTEINS FROM
   ATOMIC COORDINATES AS GIVEN BY THE BROOKHAVEN PROTEIN DATA BANK
   ORIGINAL VERSION FEB 1981 ... MAJOR REVISION JULY 1982
   AUTHORS: WOLFGANG KABSCH AND CHRISTIAN SANDER, MAX PLANCK INSTITUT
   FUER MEDIZINISCHE FORSCHUNG, JAHNSTR. 29, 6900 HEIDELBERG, GERMANY
   REFERENCE: KABSCH,W. AND SANDER,C. (1983) BIOPOLYMERS, IN PRESS *)
(*----------------------------------------------------------------------*)
LABEL 99;   (* PROGRAM FATAL ERROR EXIT LABEL *)
(*----------------------------------------------------------------------*)
(*******************  MATHEMATICAL CONSTANTS  ***************************
 YVERTEX, - ARE Y,Z-COMPONENTS OF THE FIRST ICOSAHEDRON VERTEX. THE
 ZVERTEX    X-COMPONENT IS 0.
 EPS      - NUMERICAL TOLERANCE
  ----------------------------------------------------------------------*)
CONST PIHALF=1.570796;PI=3.141593;TWOPI=6.283185;FOURPI=12.56637;
      RADIAN=57.29578;YVERTEX=0.8506508;ZVERTEX=0.5257311;EPS=0.00001;
(***************  ARRAY DIMENSIONING CONSTANTS  ***********************
 NMAX     - MAXIMUM NUMBER OF AMINOACID RESIDUES IN ARRAY CHAIN
 MAXATOM  - MAXIMUM NUMBER OF SIDECHAIN ATOMS IN ARRAY SIDECHAIN
 MAXBRIDGE- MAXIMUM NUMBER OF BRIDGES IN ARRAY BRIDGETABLE
 NFACE,   - NUMBER OF FACES OF POLYHEDRON. THE COORDINATES OF THE CENTRE
 ORDER      OF EACH TRIANGULAR FACE ARE STORED IN ARRAY P, THE AREA
            IS STORED IN ARRAY WP IN PROCEDURE FLAGACCESS. NFACE MUST BE
            OF THE FORM NFACE=20*(4**ORDER), ORDER=0,1,2,...
            THE ACCURACY OF THE SOLVENT ACCESSIBLE SURFACE OF EACH
            AMINOACID RESIDUE IS ONE ANGSTROEM**2 FOR ORDER=2,NFACE=320.
 MAXPACK  - MAXIMUM NUMBER OF PROTEIN ATOMS WHICH CAN INTRUDE INTO
            SOLVENT AROUND ANY GIVEN TEST ATOM. THE COORDINATES OF
            THESE ATOMS ARE STORED IN ARRAY X, THEIR RADII IN ARRAY RX
            IN PROCEDURE SURFACE.
 MAXHIST  - NUMBER OF SLOTS IN ARRAYS HELIXHIST AND BETAHIST USED FOR
            LENGTH STATISTICS OF SECONDARY STRUCTURE.
 MAXSS    - MAXIMUM NUMBER OF SSBOND RECORDS ON INPUT FILE. THE
            DISULFIDE BOND ARE SAVED IN ARRAY SSBONDS.
  ----------------------------------------------------------------------*)
      NMAX=1500;MAXATOM=7500;MAXBRIDGE=100;NFACE=320;ORDER=2;MAXPACK=200;
      MAXHIST=30;MAXSS=50;
(*********************  PHYSICAL CONSTANTS   ****************************
 RN       - RADIUS OF PEPTIDE NITROGEN ATOM
 RCA      - RADIUS OF PEPTIDE ALPHA-CARBON ATOM
 RC       - RADIUS OF PEPTIDE C'-CARBON ATOM
 RO       - RADIUS OF PEPTIDE OXYGEN ATOM
 RSIDEATOM- RADIUS OF SIDECHAIN ATOM
 RWATER   - RADIUS OF WATER MOLECULE
 SSDIST   - MAXIMUM ALLOWED DISTANCE OF DISULFIDE BRIDGE
 BREAKDIST- MAXIMUM ALLOWED PEPTIDE BOND LENGTH. IF DISTANCE IS
            GREATER A POLYPEPTIDE CHAIN INTERRUPTION IS ASSUMED.
 RESRAD   - MAXIMUM RADIUS OF A SPHERE AROUND C-ALPHA CONTAINING
            ALL ATOMS OF A RESIDUE
 CADIST   - MINIMUM DISTANCE BETWEEN ALPHA-CARBON ATOMS SUCH THAT NO
            BACKBONE HYDROGEN BONDS CAN BE FORMED
 DIST     - SMALLEST ALLOWED DISTANCE BETWEEN ANY ATOMS
 Q        - COUPLING CONSTANT FOR ELECTROSTATIC ENERGY
                    Q=-332*0.42*0.2*1000.0
 HBLOW    - LOWEST ALLOWED  ENERGY OF A HYDROGEN BOND IN CAL/MOL
 HBHIGH   - HIGHEST ALLOWED ENERGY OF A HYDROGEN BOND IN CAL/MOL
  ----------------------------------------------------------------------*)
      RN=1.65;RCA=1.87;RC=1.76;RO=1.4;RSIDEATOM=1.8;RWATER=1.4;
      SSDIST=3.0;BREAKDIST=2.5;RESRAD=10.0;CADIST=8.0;DIST=0.5;
      Q=-27888.0;HBLOW=-9900;HBHIGH=-500;
(***************** GLOBAL DATA TYPE DEFINITIONS ************************)
TYPE  VECTOR=ARRAY[1..3] OF REAL;ZEILE=PACKED ARRAY[1..128] OF CHAR;
      RESIDENT=PACKED ARRAY[1..6] OF CHAR;
      BRIDGETYP=(PARALLEL,ANTIPARALLEL,NOBRIDGE);
      BRIDGESET=SET OF 1..MAXBRIDGE;
      STRUCTURE=(SYMBOL,TURN3,TURN4,TURN5,BEND,CHIRALITY,BETA1,BETA2);
      HYDROGENBOND=RECORD RESIDUE,ENERGY:INTEGER END;
      BONDS=ARRAY[1..2] OF HYDROGENBOND;
      BACKBONE=RECORD
               AAIDENT:RESIDENT;
               SHEETLABEL,AA:CHAR;
               SS:PACKED ARRAY[SYMBOL..BETA2] OF CHAR;
               PARTNER:ARRAY[BETA1..BETA2] OF INTEGER;
               ACCESS:INTEGER;
               ALPHA,KAPPA:REAL;
               ACCEPTOR,DONOR:BONDS;
               H,N,CA,C,O:VECTOR;
               ATOMPOINTER,NSIDEATOMS:INTEGER;
               END;
      BRIDGE = RECORD
               SHEETNAME,LADDERNAME:CHAR;BTYP:BRIDGETYP;
               LINKSET:BRIDGESET;
               IB,IE:INTEGER;JB,JE:INTEGER;FROM,TOWARDS:INTEGER;
               END;
VAR   NSS,NIN,NSSINTRA,NSSINTER,LCHAIN,NBRIDGE:INTEGER;
      DSNAME,DSNAME2,DSNAME3:VARYING [256] OF CHAR;
      REPLY:CHAR;
      SSBONDS:ARRAY[1..MAXSS,1..2] OF RESIDENT;
      CHAIN:ARRAY[0..NMAX] OF BACKBONE;TAPEIN,TAPEOUT:TEXT;
	MINI:TEXT;
      SIDECHAIN:ARRAY[1..MAXATOM] OF VECTOR;
      BRIDGETABLE:ARRAY[1..MAXBRIDGE] OF BRIDGE;
(*----------------------------------------------------------------------*)
PROCEDURE DATE(VAR YEAR,MONTH,DAY:INTEGER);EXTERN;
FUNCTION ATAN2(Y,X:REAL):REAL;
VAR   Z:REAL;
BEGIN IF X<>0.0 THEN Z:=ARCTAN(Y/X) ELSE IF Y>0.0 THEN Z:=PIHALF ELSE
      IF Y<0.0 THEN Z:=-PIHALF ELSE Z:=TWOPI;
      IF X<0.0 THEN IF Y>0.0 THEN Z:=Z+PI ELSE Z:=Z-PI;ATAN2:=Z;
END;  (* ATAN2 *)
PROCEDURE DIFF(X,Y:VECTOR;VAR Z:VECTOR);
BEGIN Z[1]:=X[1]-Y[1];Z[2]:=X[2]-Y[2];Z[3]:=X[3]-Y[3] END;(* DIFF *)
FUNCTION DOT(X,Y:VECTOR):REAL;
BEGIN DOT:=X[1]*Y[1]+X[2]*Y[2]+X[3]*Y[3] END;(* DOT *)
PROCEDURE CROSS(X,Y:VECTOR;VAR Z:VECTOR);
BEGIN Z[1]:=X[2]*Y[3]-Y[2]*X[3];
      Z[2]:=X[3]*Y[1]-Y[3]*X[1];
      Z[3]:=X[1]*Y[2]-Y[1]*X[2];
END;(* CROSS *)
PROCEDURE NORM(VAR X:VECTOR;VAR XNORM:REAL);
(* RETURNS INPUT VECTOR X NORMALIZED TO UNIT LENGTH.
   XNORM IS THE ORIGINAL LENGTH OF X.                         *)
BEGIN XNORM:=SQR(X[1])+SQR(X[2])+SQR(X[3]);IF XNORM>0.0 THEN
      BEGIN XNORM:=SQRT(XNORM);X[1]:=X[1]/XNORM;
            X[2]:=X[2]/XNORM;X[3]:=X[3]/XNORM
END;  END;  (* NORM *)
FUNCTION DIHEDRALANGLE(V1,V2,V3,V4:VECTOR):REAL;
(*CALCULATES TORSION ANGLE OF A SET OF 4 ATOMS V1-V2-V3-V4.
  DIHEDRALANGLE IS THE ANGLE BETWEEN THE PROJECTION OF
  V1-V2 AND THE PROJECTION OF V4-V3 ONTO A PLANE NORMAL TO
  BOND V2-V3.
*)
VAR I:INTEGER;U,V:REAL;V12,V43,X,Y,Z,P:VECTOR;
BEGIN DIFF(V1,V2,V12);DIFF(V4,V3,V43);DIFF(V2,V3,Z);
      CROSS(Z,V12,P);CROSS(Z,V43,X);CROSS(Z,X,Y);U:=DOT(X,X);V:=DOT(Y,Y);
      DIHEDRALANGLE:=360.0;IF (U>0.0) AND (V>0.0) THEN
      BEGIN U:=DOT(P,X)/SQRT(U);V:=DOT(P,Y)/SQRT(V);
             IF (U<>0.0)OR(V<>0.0) THEN DIHEDRALANGLE:=ATAN2(V,U)*RADIAN
END;  END;(* DIHEDRALANGLE *)
FUNCTION COSANGLE(V1,V2,V3,V4:VECTOR):REAL;
VAR  U,V:VECTOR;X:REAL;
BEGIN DIFF(V1,V2,U);DIFF(V3,V4,V);X:=DOT(U,U)*DOT(V,V);
      IF X>0.0 THEN COSANGLE:=DOT(U,V)/SQRT(X) ELSE COSANGLE:=0.0;
END;(* COSANGLE *)
FUNCTION DISTANCE(U,V:VECTOR):REAL;
BEGIN DISTANCE:=SQRT(SQR(U[1]-V[1])+SQR(U[2]-V[2])+SQR(U[3]-V[3])) END;
(*----------------------------------------------------------------------*)
FUNCTION SENTINELTEST(I,J:INTEGER):BOOLEAN;
VAR   K:INTEGER;TEST:BOOLEAN;
BEGIN TEST:=NOT((I<1)OR(J>NMAX)OR(I>J));K:=I;
      WHILE TEST AND (K<=J) DO
      IF CHAIN[K].AA='!' THEN TEST:=FALSE ELSE K:=K+1;
      SENTINELTEST:=TEST;
END;(* SENTINELTEST *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE INPUTCOORDINATES(VAR LCHAIN:INTEGER);
VAR   AASYMBOL:PACKED ARRAY[1..50] OF CHAR;S:STRUCTURE;
      AMINOACID:PACKED ARRAY[1..150] OF CHAR;
      STRING:ARRAY[1..5] OF PACKED ARRAY[1..30] OF CHAR;
      KEY,ATOMNAME,LASTATOMNAME:PACKED ARRAY[1..4] OF CHAR;
      YEAR,MONTH,DAY,I,J,K,L,LATOM:INTEGER;A:CHAR;CORELIMIT:BOOLEAN;
      LINE:ZEILE;HPOSITION,COORDINATES:VECTOR;DCO:REAL;
      HB0:HYDROGENBOND;
BEGIN AASYMBOL:='ARNDCEQGHILKMFPSTWYVBZXXXXXXXXXXXXXXXX--CCCCIPPPW-';
      STRING[1]:='ALAARGASNASPCYSGLUGLNGLYHISILE';
      STRING[2]:='LEULYSMETPHEPROSERTHRTRPTYRVAL';
      STRING[3]:='ASXGLXACDALBALIABUAROBASBETHSE';
      STRING[4]:='HYPHYLORNPCASARTAUTHYUNKACEFOR';
      STRING[5]:='CYHCSHCSSCYXILUPRZPR0CPRTRYHOH';
      L:=0;FOR K:=1 TO 5 DO FOR I:=1 TO 30 DO
      BEGIN L:=L+1;AMINOACID[L]:=STRING[K,I] END;
      HB0.RESIDUE:=0;HB0.ENERGY:=0;
      FOR I:=0 TO NMAX DO WITH CHAIN[I] DO
      BEGIN FOR J:=1 TO 6 DO AAIDENT[J]:=' ';AA:='!';ACCESS:=0;
            FOR S:=SYMBOL TO BETA2 DO SS[S]:=' ';SHEETLABEL:=' ';
            PARTNER[BETA1]:=0;PARTNER[BETA2]:=0;ALPHA:=360.0;KAPPA:=360.0;
            FOR J:=1 TO 2 DO BEGIN ACCEPTOR[J]:=HB0;DONOR[J]:=HB0 END;
            ATOMPOINTER:=0;NSIDEATOMS:=0;FOR J:=1 TO 3 DO
            BEGIN H[J]:=0.0;N[J]:=0.0;CA[J]:=0.0;C[J]:=0.0;O[J]:=0.0 END;
      END;NSS:=0;LATOM:=0;(*DATE(YEAR,MONTH,DAY);*)
      WRITE(TAPEOUT,'**** SECONDARY STRUCTURE DEFINITION ***');
      WRITELN(OUTPUT,'GIVE DAY:MONTH:YEAR (e.g.1 11 1983)');
      READLN(INPUT,DAY,MONTH,YEAR);
      WRITE(TAPEOUT,' MONTH=',MONTH:2,' DAY=',DAY:2,' YEAR=',YEAR:4);
      FOR I:=66 TO 120 DO WRITE(TAPEOUT,' ');WRITELN(TAPEOUT,'.');
      WRITE(TAPEOUT,'REFERENCE: KABSCH,W. AND SANDER,C. (1983) BIOPOLYMERS');
      FOR I:=54 TO 120 DO WRITE(TAPEOUT,' ');WRITELN(TAPEOUT,'.');
      (*repeat READ(TAPEIN,A) UNTIL A='H';WRITE(TAPEOUT,A);
      FOR I:=2 TO 66 DO BEGIN READ(TAPEIN,A);WRITE(TAPEOUT,A) END;
      READLN(TAPEIN);FOR I:=67 TO 120 DO WRITE(TAPEOUT,' ');
      WRITELN(TAPEOUT,'.');FOR I:=1 TO 70 DO
      BEGIN READ(TAPEIN,A);WRITE(TAPEOUT,A) END;READLN(TAPEIN);
      FOR I:=71 TO 120 DO WRITE(TAPEOUT,' ');WRITELN(TAPEOUT,'.');
      REPEAT READ(TAPEIN,A);IF A<>'S' THEN READLN(TAPEIN);UNTIL A='S';
      WRITE(TAPEOUT,A);FOR I:=2 TO 70 DO
      BEGIN READ(TAPEIN,A);WRITE(TAPEOUT,A) END;READLN(TAPEIN);
      FOR I:=71 TO 120 DO WRITE(TAPEOUT,' ');WRITELN(TAPEOUT,'.');
      REPEAT READ(TAPEIN,A);IF A<>'A' THEN READLN(TAPEIN);UNTIL A='A';
      WRITE(TAPEOUT,A);FOR I:=2 TO 70 DO
      BEGIN READ(TAPEIN,A);WRITE(TAPEOUT,A) END;READLN(TAPEIN);
      FOR I:=71 TO 120 DO WRITE(TAPEOUT,' ');WRITELN(TAPEOUT,'.');*)
      LASTATOMNAME:='    ';CORELIMIT:=FALSE;KEY:='....';
      WHILE NOT (EOF(TAPEIN) OR CORELIMIT OR (KEY='END ')) DO
      BEGIN FOR I:=1 TO 4 DO READ(TAPEIN,KEY[I]);IF KEY='ATOM' THEN
            BEGIN FOR I:=5 TO 30 DO READ(TAPEIN,LINE[I]);
                  FOR I:=1 TO 4 DO ATOMNAME[I]:=LINE[I+12];
                  A:='-';I:=1;K:=1;WHILE (K<51) AND (A='-') DO
                  BEGIN IF AMINOACID[I]=LINE[18] THEN
                        IF AMINOACID[I+1]=LINE[19] THEN
                        IF AMINOACID[I+2]=LINE[20] THEN A:=AASYMBOL[K];
                        I:=I+3;K:=K+1;
                  END;  IF (A<>'-') AND (ATOMNAME<>LASTATOMNAME) THEN
                  BEGIN FOR I:=1 TO 3 DO READ(TAPEIN,COORDINATES[I]);
                        LASTATOMNAME:=ATOMNAME;IF ATOMNAME=' N  ' THEN
                        BEGIN IF SENTINELTEST(LCHAIN,LCHAIN) THEN
                              IF(DISTANCE(CHAIN[LCHAIN].C,COORDINATES)>
                                 BREAKDIST)
                              OR(LINE[22]<>CHAIN[LCHAIN].AAIDENT[6])
                              THEN LCHAIN:=LCHAIN+1;
                              IF NOT SENTINELTEST(LCHAIN,LCHAIN)OR(A='P')
                              THEN HPOSITION:=COORDINATES
                              ELSE WITH CHAIN[LCHAIN] DO
                              BEGIN DCO:=DISTANCE(C,O);
                                    FOR I:=1 TO 3 DO
                                    HPOSITION[I]:=COORDINATES[I]+
                                                  (C[I]-O[I])/DCO;
                              END;IF (LCHAIN+2)>NMAX THEN CORELIMIT:=TRUE
                              ELSE
                              BEGIN LCHAIN:=LCHAIN+1;WITH CHAIN[LCHAIN] DO
                                    BEGIN AA:=A;ATOMPOINTER:=LATOM;
                                          AAIDENT[6]:=LINE[22];
                                          FOR I:=1 TO 5 DO
                                          AAIDENT[I]:=LINE[I+22];
                                          H:=HPOSITION;N:=COORDINATES;
                        END   END   END   ELSE  WITH CHAIN[LCHAIN] DO
                        IF ATOMNAME=' CA ' THEN CA:=COORDINATES ELSE
                        IF ATOMNAME=' C  ' THEN  C:=COORDINATES ELSE
                        IF ATOMNAME=' O  ' THEN  O:=COORDINATES ELSE
                        BEGIN LATOM:=LATOM+1;
                              IF LATOM>MAXATOM THEN CORELIMIT:=TRUE ELSE
                              BEGIN NSIDEATOMS:=NSIDEATOMS+1;
                                    SIDECHAIN[LATOM]:=COORDINATES;
            END;  END;  END;  END;  IF KEY='SSBO' THEN
            BEGIN NSS:=NSS+1;FOR I:=5 TO 36 DO READ(TAPEIN,LINE[I]);
                  J:=0;FOR K:=1 TO 2 DO
                  BEGIN FOR I:=1 TO 5 DO SSBONDS[NSS,K][I]:=LINE[I+J+17];
                        SSBONDS[NSS,K][6]:=LINE[16+J];J:=J+14;
            END;  END;  READLN(TAPEIN);
      END;  IF CORELIMIT THEN
      WRITELN(' !!! NUMBER OF ATOMS EXCEEDS STORAGE CAPACITY !!!');
      IF LCHAIN=0 THEN
      BEGIN WRITELN(' !!! BACKBONE COORDINATE SET INCOMPLETE !!!');
            GOTO 99;
      END;
      IF LATOM=0 THEN
      WRITELN(' !!! ALL SIDECHAIN COORDINATES MISSING !!!');
END;(* INPUTCOORDINATES *)
(*----------------------------------------------------------------------*)
FUNCTION TESTBOND(I,J:INTEGER):BOOLEAN;
(* TESTBOND IS TRUE IF I IS DONOR[=NH] TO J, OTHERWISE FALSE *)
BEGIN WITH CHAIN[I] DO
      TESTBOND:=((ACCEPTOR[1].RESIDUE=J)AND(ACCEPTOR[1].ENERGY<HBHIGH))
              OR((ACCEPTOR[2].RESIDUE=J)AND(ACCEPTOR[2].ENERGY<HBHIGH))
END;(* TESTBOND *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGSSBONDS;
VAR SSBOND:BOOLEAN;CC:CHAR;I,J,II,JJ:INTEGER;D:REAL;
FUNCTION TESTSSBOND(I,J:INTEGER):BOOLEAN;
VAR   SSBOND:BOOLEAN;K:INTEGER;
BEGIN SSBOND:=FALSE;K:=1;IF SENTINELTEST(I,I) AND SENTINELTEST(J,J) THEN
      WHILE NOT (SSBOND OR (K>NSS)) DO
      BEGIN SSBOND:=((CHAIN[I].AAIDENT=SSBONDS[K,1])AND
                     (CHAIN[J].AAIDENT=SSBONDS[K,2]))OR
                    ((CHAIN[I].AAIDENT=SSBONDS[K,2])AND
                     (CHAIN[J].AAIDENT=SSBONDS[K,1]));K:=K+1;
      END;  TESTSSBOND:=SSBOND;
END;  (* TESTSSBONDS *)
BEGIN NSSINTRA:=0;NSSINTER:=0;CC:=PRED('a');FOR I:=1 TO LCHAIN-2 DO
      IF (CHAIN[I].AA='C')AND(CHAIN[I].NSIDEATOMS>1) THEN
      BEGIN II:=CHAIN[I].ATOMPOINTER+2;J:=I+1;
            REPEAT J:=J+1;SSBOND:=FALSE;
                   IF (CHAIN[J].NSIDEATOMS>1)AND(CHAIN[J].AA='C') THEN
                   JJ:=CHAIN[J].ATOMPOINTER+2 ELSE JJ:=0;
                   IF JJ>0 THEN
                   SSBOND:=DISTANCE(SIDECHAIN[II],SIDECHAIN[JJ])<SSDIST;
            UNTIL  SSBOND OR (J=LCHAIN);
            IF (SSBOND) AND NOT TESTSSBOND(I,J) THEN
            WRITELN(' !!! ADDITIONAL SSBOND FOUND BETWEEN RESIDUES'
                           ,I:4, ' AND',J:4,' !!!');
      END;  IF NSS>0 THEN FOR I:=1 TO LCHAIN-2 DO WITH CHAIN[I] DO
      IF AA='C' THEN FOR J:=I+2 TO LCHAIN DO IF CHAIN[J].AA='C' THEN
      IF TESTSSBOND(I,J) THEN
      BEGIN IF CC='z' THEN
            BEGIN WRITELN(' !!! SS-BRIDGE LABEL RESTART AT a !!!');
                  CC:=PRED('a');
            END;  CC:=SUCC(CC);AA:=CC;CHAIN[J].AA:=CC;
            IF SENTINELTEST(I,J) THEN NSSINTRA:=NSSINTRA+1
                                 ELSE NSSINTER:=NSSINTER+1;
            IF NSIDEATOMS>1 THEN IF CHAIN[J].NSIDEATOMS>1 THEN
            BEGIN JJ:=CHAIN[J].ATOMPOINTER+2;II:=ATOMPOINTER+2;
                  D:=DISTANCE(SIDECHAIN[II],SIDECHAIN[JJ]);
                  IF D>SSDIST THEN WRITELN(' !!! SSBOND DISTANCE IS',
                  D:5:1,' BETWEEN RESIDUES',I:5,' AND',J:5,' !!!');
      END;  END;  IF NSS<>(NSSINTRA+NSSINTER) THEN
      WRITELN(' !!! ERROR IN SSBOND DATA RECORDS !!!');
END;  (* FLAGSSBONDS *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGCHIRALITY;
VAR   I:INTEGER;CKAP,SKAP:REAL;
BEGIN FOR I:=2 TO LCHAIN-2 DO WITH CHAIN[I] DO
      IF SENTINELTEST(I-1,I+2) THEN
      BEGIN
      ALPHA:=DIHEDRALANGLE(CHAIN[I-1].CA,CA,CHAIN[I+1].CA,CHAIN[I+2].CA);
      IF ALPHA<0.0 THEN SS[CHIRALITY]:='-' ELSE SS[CHIRALITY]:='+';
      END;
      FOR I:=3 TO LCHAIN-2 DO WITH CHAIN[I] DO
      IF SENTINELTEST(I-2,I+2) THEN BEGIN
      CKAP:=COSANGLE(CHAIN[I].CA,CHAIN[I-2].CA,CHAIN[I+2].CA,CHAIN[I].CA);
      SKAP:=SQRT(1-CKAP*CKAP);KAPPA:=RADIAN*ATAN2(SKAP,CKAP);
      END;
 END;(* CHIRALITY *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGHYDROGENBONDS;
VAR  I,J:INTEGER;
FUNCTION BONDENERGY(I,J:INTEGER):INTEGER;
(*RESIDUE I IS DONOR[=NH],J IS ACCEPTOR[=CO] OF THE PROTON IN THE
   HYDROGEN BOND. THE BONDENERGY IS IN CAL/MOL *)
VAR   DHO,DHC,DNC,DNO:REAL;HBE:INTEGER;
BEGIN HBE:=0;WITH CHAIN[I] DO IF AA<>'P' THEN
      BEGIN DHO:=DISTANCE(H,CHAIN[J].O);DHC:=DISTANCE(H,CHAIN[J].C);
            DNC:=DISTANCE(N,CHAIN[J].C);DNO:=DISTANCE(N,CHAIN[J].O);
            IF (DHO<DIST)OR(DHC<DIST)OR(DNC<DIST)OR(DNO<DIST) THEN
            HBE:=HBLOW ELSE HBE:=ROUND(Q/DHO-Q/DHC+Q/DNC-Q/DNO);
            IF HBE<=HBLOW THEN
            BEGIN WRITELN(' !!! CONTACT BETWEEN RESIDUES',I:5,' AND',J:5,
                             '  TOO CLOSE !!!');HBE:=HBLOW;
      END;  END;BONDENERGY:=HBE
END;  (* BONDENERGY *)
PROCEDURE UPDATEBONDS(VAR B:BONDS;HB:HYDROGENBOND);
BEGIN IF HB.ENERGY<B[1].ENERGY THEN
      BEGIN B[2]:=B[1];B[1]:=HB END
      ELSE IF HB.ENERGY<B[2].ENERGY THEN B[2]:=HB
END;(* UPDATEBONDS *)
PROCEDURE SETBONDS(I,J:INTEGER); (*I IS NH, J IS CO*)
VAR   HB:HYDROGENBOND;
BEGIN HB.ENERGY:=BONDENERGY(I,J);HB.RESIDUE:=J;
      (* CO(J) IS ACCEPTOR OF NH(I) *)
      UPDATEBONDS(CHAIN[I].ACCEPTOR,HB);
      HB.RESIDUE:=I;UPDATEBONDS(CHAIN[J].DONOR,HB)
END;(* SETBOND *)
BEGIN FOR I:=1 TO LCHAIN DO IF SENTINELTEST(I,I) THEN WITH CHAIN[I] DO
      FOR J:=I+1 TO LCHAIN DO IF SENTINELTEST(J,J) THEN
      IF DISTANCE(CA,CHAIN[J].CA)<CADIST THEN
      BEGIN SETBONDS(I,J);IF J<>(I+1) THEN SETBONDS(J,I) END;
END;  (* FLAGHYDROGENBONDS *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGBRIDGE;
VAR   I:INTEGER;
PROCEDURE TESTBRIDGE(I:INTEGER);
VAR   J1,J2,J:INTEGER;B:BRIDGETYP;
PROCEDURE LADDER(I,J:INTEGER;B:BRIDGETYP);
VAR   K:INTEGER;FOUND:BOOLEAN;
BEGIN FOUND:=FALSE;K:=1;IF (B<>NOBRIDGE)AND(I<J) THEN
      REPEAT WITH BRIDGETABLE[K] DO
             IF IB=0 THEN
             BEGIN IB:=I;IE:=I;JB:=J;JE:=J;FROM:=0;TOWARDS:=0;
                   BTYP:=B;NBRIDGE:=NBRIDGE+1;FOUND:=TRUE;
             END   ELSE
             BEGIN FOUND:=(BTYP=B)AND(I=(IE+1))AND SENTINELTEST(IE,I)AND
                   (((J=(JE+1))AND(B=PARALLEL)AND SENTINELTEST(JE,J))OR
                 ((J=(JB-1))AND(B=ANTIPARALLEL)AND SENTINELTEST(J,JB)));
                   IF FOUND THEN
                   BEGIN IE:=IE+1;
                         IF B=PARALLEL THEN JE:=JE+1 ELSE JB:=JB-1
                   END  ELSE
                   BEGIN K:=K+1;IF K>MAXBRIDGE THEN
                         BEGIN WRITELN(' !!! BRIDGETABLE OVERFLOW !!!');
                               GOTO 99;
             END;  END;  END;
      UNTIL  FOUND
END;  (* LADDER *)
BEGIN J1:=0;J2:=0;J:=I+3;IF SENTINELTEST(I-1,I+1) THEN
      WHILE (J2=0)AND(J<LCHAIN) DO
      BEGIN IF SENTINELTEST(J-1,J+1) THEN
            BEGIN IF (TESTBOND(I+1,J) AND TESTBOND(J  ,I-1))OR
                     (TESTBOND(J+1,I)  AND TESTBOND(I  ,J-1))
                  THEN B:=PARALLEL ELSE
                  IF (TESTBOND(I+1,J-1)AND TESTBOND(J+1,I-1))OR
                     (TESTBOND(J  ,I  )AND TESTBOND(I  ,J  ))
                  THEN B:=ANTIPARALLEL ELSE B:=NOBRIDGE;
                  IF B<>NOBRIDGE THEN
                  BEGIN IF J1=0 THEN BEGIN J1:=J;LADDER(I,J,B) END
                                ELSE IF J<>J1 THEN
                                     BEGIN J2:=J;LADDER(I,J,B) END;
            END;  END;  J:=J+1;
END;  END;  (* TESTBRIDGE *)
PROCEDURE EXTENDLADDER;
VAR   I,J,IB1,JB1,JE1:INTEGER;BULGE:BOOLEAN;
BEGIN FOR I:=1 TO NBRIDGE DO WITH BRIDGETABLE[I] DO
      BEGIN J:=I+1;WHILE (J<=NBRIDGE)AND(TOWARDS=0) DO
            BEGIN IB1:=BRIDGETABLE[J].IB;
                  JB1:=BRIDGETABLE[J].JB;JE1:=BRIDGETABLE[J].JE;
                  BULGE:=SENTINELTEST(IE,IB1)AND((IB1-IE)<6)AND
                  (BRIDGETABLE[J].BTYP=BTYP)AND(BRIDGETABLE[J].FROM=0);
                  IF BULGE THEN CASE BTYP OF
PARALLEL:         BULGE:=((((JB1-JE)<6)AND((IB1-IE)<3))OR
                          ((JB1-JE)<3))AND SENTINELTEST(JE,JB1);
ANTIPARALLEL:     BULGE:=((((JB-JE1)<6)AND((IB1-IE)<3))OR
                         ((JB-JE1)<3))AND SENTINELTEST(JE1,JB);
                  END;IF BULGE THEN
                  BEGIN TOWARDS:=J;BRIDGETABLE[J].FROM:=I END;J:=J+1;
      END;  END;
      FOR I:=1 TO NBRIDGE DO WITH BRIDGETABLE[I] DO IF FROM=0 THEN
      BEGIN LINKSET:=[];J:=I;
            REPEAT LINKSET:=LINKSET+[J];J:=BRIDGETABLE[J].TOWARDS
            UNTIL  J=0;J:=TOWARDS;WHILE J<>0 DO
            BEGIN BRIDGETABLE[J].LINKSET:=LINKSET;
                  J:=BRIDGETABLE[J].TOWARDS
END;  END;  END;  (* EXTENDLADDER *)
PROCEDURE SHEET;
VAR   ASCI,I,J:INTEGER;CCS:CHAR;LADDERSET,SHEETSET:BRIDGESET;
PROCEDURE FINDSHEET;
VAR   L1,L2:INTEGER;FINISH:BOOLEAN;
FUNCTION LINK(L1,L2:INTEGER):BOOLEAN;
(* LINK IS TRUE IF THERE IS A COMMON RESIDUE IN LADDERS L1 AND L2 *)
VAR   IB1,IE1,JB1,JE1,IB2,IE2,JB2,JE2:INTEGER;
BEGIN IB1:=BRIDGETABLE[L1].IB;IE1:=BRIDGETABLE[L1].IE;
      JB1:=BRIDGETABLE[L1].JB;JE1:=BRIDGETABLE[L1].JE;
      IB2:=BRIDGETABLE[L2].IB;IE2:=BRIDGETABLE[L2].IE;
      JB2:=BRIDGETABLE[L2].JB;JE2:=BRIDGETABLE[L2].JE;
      LINK:=((IE1>=IB2)AND(IB1<=IE2))OR((IE1>=JB2)AND(IB1<=JE2))
          OR((JE1>=IB2)AND(JB1<=IE2))OR((JE1>=JB2)AND(JB1<=JE2));
END;  (* LINK *)
BEGIN SHEETSET:=[];L1:=0;IF LADDERSET<>[] THEN
      REPEAT L1:=L1+1 UNTIL L1 IN LADDERSET;IF L1>0 THEN
      SHEETSET:=BRIDGETABLE[L1].LINKSET;IF L1>0 THEN
      REPEAT FINISH:=TRUE;FOR L1:=1 TO NBRIDGE DO IF L1 IN SHEETSET THEN
             FOR L2:=1 TO NBRIDGE DO IF L2 IN LADDERSET THEN
             IF LINK(L1,L2) THEN
             BEGIN SHEETSET:=SHEETSET+BRIDGETABLE[L2].LINKSET;
                   LADDERSET:=LADDERSET-BRIDGETABLE[L2].LINKSET;
                   FINISH:=FALSE;
             END;
      UNTIL  FINISH;
END;  (* FINDSHEET *)
BEGIN LADDERSET:=[];FOR I:=1 TO NBRIDGE DO LADDERSET:=LADDERSET+[I];
      CCS:=PRED('A');ASCI:=64;WHILE LADDERSET<>[] DO
      BEGIN CCS:=SUCC(CCS);IF CCS>'z' THEN
            BEGIN WRITELN(' !!! SHEET LABEL RESTART AT A !!!');
                  CCS:='A';
            END;  FINDSHEET;FOR I:=1 TO NBRIDGE DO
            WITH BRIDGETABLE[I] DO IF (I IN SHEETSET)AND(FROM=0) THEN
            BEGIN IF ASCI=90 THEN
                  BEGIN WRITELN(' !!! STRAND LABEL RESTART AT A !!!');
                        ASCI:=64;
                  END;  ASCI:=ASCI+1;IF BTYP=PARALLEL THEN
                  LADDERNAME:=CHR(ASCI+32) ELSE LADDERNAME:=CHR(ASCI);
                  SHEETNAME:=CCS;LINKSET:=SHEETSET;J:=TOWARDS;
                  WHILE J<>0 DO
                  BEGIN BRIDGETABLE[J].LADDERNAME:=LADDERNAME;
                        BRIDGETABLE[J].SHEETNAME :=SHEETNAME ;
                        BRIDGETABLE[J].LINKSET:=SHEETSET;
                        J:=BRIDGETABLE[J].TOWARDS
END;  END;  END;  END;  (* SHEET *)
PROCEDURE MARKSTRANDS;
VAR   I,J,L,IB0,IE0,JB0,JE0:INTEGER;BETA,BETAI,BETAJ:STRUCTURE;
      ISET,JSET:ARRAY[BETA1..BETA2] OF SET OF CHAR;CC:CHAR;
BEGIN FOR I:=1 TO NBRIDGE DO IF BRIDGETABLE[I].FROM=0 THEN
      BEGIN J:=I;FOR BETA:=BETA1 TO BETA2 DO
            BEGIN ISET[BETA]:=[];JSET[BETA]:=[] END;
            IB0:=LCHAIN;IE0:=0;JB0:=LCHAIN;JE0:=0;
            REPEAT WITH BRIDGETABLE[J] DO
                   BEGIN FOR L:=IB TO IE DO WITH CHAIN[L] DO
                         FOR BETA:=BETA1 TO BETA2 DO
                         ISET[BETA]:=ISET[BETA]+[SS[BETA]];
                         FOR L:=JB TO JE DO WITH CHAIN[L] DO
                         FOR BETA:=BETA1 TO BETA2 DO
                         JSET[BETA]:=JSET[BETA]+[SS[BETA]];
                         IF IB<IB0 THEN IB0:=IB;IF IE>IE0 THEN IE0:=IE;
                         IF JB<JB0 THEN JB0:=JB;IF JE>JE0 THEN JE0:=JE;
                         J:=TOWARDS;
                   END
            UNTIL  J=0;J:=I;
            IF ISET[BETA1]=[' '] THEN BETAI:=BETA1 ELSE BETAI:=BETA2;
            IF JSET[BETA1]=[' '] THEN BETAJ:=BETA1 ELSE BETAJ:=BETA2;
            IF (ISET[BETAI]<>[' '])OR(JSET[BETAJ]<>[' ']) THEN
            WRITELN(' !!! STRAND COLUMN OVERWRITTEN !!!');
            REPEAT WITH BRIDGETABLE[J] DO
                   BEGIN FOR L:=IB TO IE DO WITH CHAIN[L] DO
                         BEGIN SS[BETAI]:=LADDERNAME;IF BTYP=PARALLEL THEN
                               PARTNER[BETAI]:=JB+L-IB ELSE
                               PARTNER[BETAI]:=JE-L+IB;
                         END;  FOR L:=JB TO JE DO WITH CHAIN[L] DO
                         BEGIN SS[BETAJ]:=LADDERNAME;IF BTYP=PARALLEL THEN
                               PARTNER[BETAJ]:=IB+L-JB  ELSE
                               PARTNER[BETAJ]:=IE-L+JB;
                         END;  J:=TOWARDS;
                   END
            UNTIL  J=0;  IF IB0=IE0 THEN CC:='B' ELSE CC:='E';
            FOR J:=IB0 TO IE0 DO WITH CHAIN[J] DO
            IF SS[SYMBOL]<>'E' THEN SS[SYMBOL]:=CC;
            FOR J:=JB0 TO JE0 DO WITH CHAIN[J] DO
            IF SS[SYMBOL]<>'E' THEN SS[SYMBOL]:=CC;
      END;  FOR J:=1 TO NBRIDGE DO WITH BRIDGETABLE[J] DO
      BEGIN FOR L:=IB TO IE DO CHAIN[L].SHEETLABEL:=SHEETNAME;
            FOR L:=JB TO JE DO CHAIN[L].SHEETLABEL:=SHEETNAME;
END;  END;  (* MARKSTRANDS *)
BEGIN FOR I:=1 TO MAXBRIDGE DO WITH BRIDGETABLE[I] DO
      BEGIN IB:=0;IE:=0;JB:=0;JE:=0;BTYP:=NOBRIDGE END;
      NBRIDGE:=0;FOR I:=2 TO LCHAIN-1 DO TESTBRIDGE(I);
      IF NBRIDGE>0 THEN BEGIN EXTENDLADDER;SHEET;MARKSTRANDS END;
END;  (* FLAGBRIDGE *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGTURN;
VAR   I,J,K:INTEGER;TURN:STRUCTURE;CC:CHAR;
PROCEDURE FLAGSYMBOL;
(* FLAGS ALPHA HELICES AND TURNS IN SYMBOL COLUMN *)
VAR   I,J,K:INTEGER;CC:CHAR;NHSET:SET OF CHAR;TURN:STRUCTURE;
      EMPTY:BOOLEAN;
BEGIN NHSET:=['>','X'];FOR I:=2 TO LCHAIN-4 DO
      IF (CHAIN[I-1].SS[TURN4] IN NHSET) AND
         (CHAIN[I].SS[TURN4] IN NHSET) THEN
      FOR J:=I TO I+3 DO CHAIN[J].SS[SYMBOL]:='H';
      FOR I:=2 TO LCHAIN-3 DO IF (CHAIN[I-1].SS[TURN3] IN NHSET)AND
                                 (CHAIN[I  ].SS[TURN3] IN NHSET)THEN
      BEGIN EMPTY:=TRUE;FOR J:=I TO I+2 DO WITH CHAIN[J] DO
            IF NOT (SS[SYMBOL] IN [' ','G']) THEN EMPTY:=FALSE;
            IF EMPTY THEN FOR J:=I TO I+2 DO CHAIN[J].SS[SYMBOL]:='G'
      END;
      FOR I:=2 TO LCHAIN-5 DO IF (CHAIN[I-1].SS[TURN5] IN NHSET)AND
                                 (CHAIN[I  ].SS[TURN5] IN NHSET)THEN
      BEGIN EMPTY:=TRUE;FOR J:=I TO I+4 DO WITH CHAIN[J] DO
            IF NOT (SS[SYMBOL] IN [' ','I']) THEN EMPTY:=FALSE;
            IF EMPTY THEN FOR J:=I TO I+4 DO CHAIN[J].SS[SYMBOL]:='I'
      END;
      FOR I:=2 TO LCHAIN-1 DO WITH CHAIN[I] DO IF SS[SYMBOL]=' ' THEN
      BEGIN CC:=' ';J:=1;FOR TURN:=TURN3 TO TURN5 DO
            BEGIN J:=J+1;FOR K:=1 TO J DO IF I>K THEN
                  IF CHAIN[I-K].SS[TURN] IN NHSET THEN CC:='T';
            END;IF (CC=' ') THEN CC:=SS[BEND];SS[SYMBOL]:=CC;
END;  END; (* FLAGSYMBOL *)
BEGIN K:=2;CC:='2';FOR TURN:=TURN3 TO TURN5 DO
      BEGIN K:=K+1;CC:=SUCC(CC);FOR I:=1 TO LCHAIN-K DO
            IF SENTINELTEST(I,I+K) THEN IF TESTBOND(I+K,I) THEN
            BEGIN CHAIN[I+K].SS[TURN]:='<';FOR J:=1 TO K-1 DO
                  WITH CHAIN[I+J] DO IF SS[TURN]=' ' THEN SS[TURN]:=CC;
                  WITH CHAIN[I] DO IF SS[TURN]='<' THEN
                  SS[TURN]:='X' ELSE SS[TURN]:='>';
      END;  END;
      FOR I:=1 TO LCHAIN DO WITH CHAIN[I] DO
      IF (KAPPA<>360.0) AND (KAPPA>70.0) THEN SS[BEND]:='S';
      FLAGSYMBOL;
END;(* FLAGTURN *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE FLAGACCESS;
VAR   I,K,NP:INTEGER;F:REAL;P:ARRAY[1..NFACE] OF VECTOR;
      WP:ARRAY[1..NFACE] OF REAL;
PROCEDURE POLYEDER;
VAR   V:ARRAY[1..12] OF VECTOR;A,B:REAL;I,J,K,LEVEL:INTEGER;
PROCEDURE TRIANGLE(X1,X2,X3:VECTOR;LEVEL:INTEGER);
VAR   K,LEVEL1:INTEGER;XNORM:REAL;X4,X5,X6:VECTOR;
BEGIN IF LEVEL>0 THEN
      BEGIN LEVEL1:=LEVEL-1;FOR K:=1 TO 3 DO
            BEGIN X4[K]:=X1[K]+X2[K];X5[K]:=X2[K]+X3[K];X6[K]:=X1[K]+X3[K]
            END;NORM(X4,XNORM);NORM(X5,XNORM);NORM(X6,XNORM);
            TRIANGLE(X1,X4,X6,LEVEL1);TRIANGLE(X4,X2,X5,LEVEL1);
            TRIANGLE(X4,X5,X6,LEVEL1);TRIANGLE(X5,X3,X6,LEVEL1);
      END   ELSE
      BEGIN FOR K:=1 TO 3 DO X6[K]:=X1[K]+X2[K]+X3[K];NORM(X6,XNORM);
            NP:=NP+1;P[NP]:=X6;DIFF(X3,X1,X5);DIFF(X2,X1,X4);
            CROSS(X5,X4,X6);NORM(X6,XNORM);WP[NP]:=XNORM/2.0
END;  END;  (* TRIANGLE *)
BEGIN (* GENERATES ALL 12 VERTICES OF ICOSAHEDRON *)
      K:=0;A:=YVERTEX;B:=ZVERTEX;FOR I:=1 TO 2 DO
      BEGIN A:=-A;FOR J:=1 TO 2 DO
            BEGIN B:=-B;
                  K:=K+1;V[K][1]:=0.0;V[K][2]:=A  ;V[K][3]:=B  ;
                  K:=K+1;V[K][1]:=B  ;V[K][2]:=0.0;V[K][3]:=A  ;
                  K:=K+1;V[K][1]:=A  ;V[K][2]:=B  ;V[K][3]:=0.0;
      END;  END;  NP:=0;LEVEL:=ORDER;
      (* GET ALL 20 FACES OF ICOSAHEDRON *)
      FOR I:=1 TO 10 DO FOR J:=I+1 TO 11 DO
      IF DISTANCE(V[I],V[J])<1.1 THEN FOR K:=J+1 TO 12 DO
      IF (DISTANCE(V[I],V[K])<1.1)AND(DISTANCE(V[J],V[K])<1.1) THEN
      TRIANGLE(V[I],V[J],V[K],LEVEL);(* FIND INTEGRATION POINTS *)
      A:=0.0;FOR I:=1 TO NP DO A:=A+WP[I];A:=FOURPI/A;
      FOR I:=1 TO NP DO WP[I]:=WP[I]*A;
END;  (* POLYEDER  *)
FUNCTION SURFACE(XATOM:VECTOR;RATOM:REAL):REAL;
VAR   NX,I,J:INTEGER;F,RADIUS:REAL;XX:VECTOR;
      X:ARRAY[1..MAXPACK] OF VECTOR;RX:ARRAY[1..MAXPACK] OF REAL;
FUNCTION STEP(XX:VECTOR):BOOLEAN;
VAR   K:INTEGER;ONE:BOOLEAN;
BEGIN ONE:=TRUE;K:=1;WHILE (K<=NX) AND ONE DO
      IF DISTANCE(XX,X[K])<(RX[K]+RWATER) THEN ONE:=FALSE ELSE K:=K+1;
      STEP:=ONE;
END;  (* STEP *)
PROCEDURE LISTE(XX:VECTOR;RXX:REAL);
VAR   Y,Z:VECTOR;I,K:INTEGER;D:REAL;
PROCEDURE LISTENTRY(XX,YY:VECTOR;D,R:REAL);
VAR   ZZ:VECTOR;DELTA:REAL;
BEGIN DELTA:=DISTANCE(XX,YY);IF DELTA<(D+R) THEN IF DELTA>EPS THEN
      BEGIN NX:=NX+1;IF NX>MAXPACK THEN
            BEGIN WRITELN(' !!! TABLE OVERFLOW IN FLAGACCESS !!!');GOTO 99
            END   ELSE
            BEGIN DIFF(YY,XX,ZZ);X[NX]:=ZZ;RX[NX]:=R END;
END;  END;  (* LISTENTRY *)
BEGIN NX:=0;D:=RXX+RWATER+RWATER;FOR I:=1 TO LCHAIN DO
      IF SENTINELTEST(I,I) THEN WITH CHAIN[I] DO
      IF DISTANCE(XX,CA)<(D+RESRAD) THEN
      BEGIN LISTENTRY(XX,N,D,RN);LISTENTRY(XX,CA,D,RCA);
            LISTENTRY(XX,C,D,RC);LISTENTRY(XX,O,D,RO);
            IF NSIDEATOMS>0 THEN FOR K:=1 TO NSIDEATOMS DO
            LISTENTRY(XX,SIDECHAIN[ATOMPOINTER+K],D,RSIDEATOM);
END;  END;  (* LISTE *)
BEGIN LISTE(XATOM,RATOM);RADIUS:=RATOM+RWATER;F:=0;FOR I:=1 TO NP DO
      BEGIN FOR J:=1 TO 3 DO XX[J]:=P[I][J]*RADIUS;
            IF STEP(XX) THEN F:=F+WP[I];
      END;  SURFACE:=RADIUS*RADIUS*F
END;  (* SURFACE *)
BEGIN POLYEDER;
      FOR I:=1 TO LCHAIN DO IF SENTINELTEST(I,I) THEN WITH CHAIN[I] DO
      BEGIN F:=SURFACE(N,RN)+SURFACE(CA,RCA)+SURFACE(C,RC)+SURFACE(O,RO);
            IF NSIDEATOMS>0 THEN FOR K:=1 TO NSIDEATOMS DO
            F:=F+SURFACE(SIDECHAIN[ATOMPOINTER+K],RSIDEATOM);
            ACCESS:=ROUND(F);
END;  END;  (* FLAGACCESS *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
PROCEDURE PRINTOUT;
VAR   I,J:INTEGER;S:STRUCTURE;PHI,PSI,TCO:REAL;
PROCEDURE STATISTICS;
VAR   I,J,K,NCHAIN,NRES,NHBOND,LHELIX:INTEGER;B:BRIDGETYP;CC:CHAR;
      SURFACE:REAL;NHBTURN:ARRAY[-5..5] OF INTEGER;LADDERSET:BRIDGESET;
      HBRIDGE:ARRAY[PARALLEL..ANTIPARALLEL] OF INTEGER;
      HELIXHIST,SHEETHIST:ARRAY[1..MAXHIST] OF INTEGER;
      BETAHIST:ARRAY[PARALLEL..ANTIPARALLEL,1..MAXHIST] OF INTEGER;
BEGIN LHELIX:=0;NHBOND:=0;NCHAIN:=0;NRES:=0;FOR I:=1 TO MAXHIST DO
      BEGIN FOR B:=PARALLEL TO ANTIPARALLEL DO BETAHIST[B][I]:=0;
            HELIXHIST[I]:=0;SHEETHIST[I]:=0
      END;  SURFACE:=0.0;FOR K:=-5 TO 5 DO NHBTURN[K]:=0;
      FOR B:=PARALLEL TO ANTIPARALLEL DO HBRIDGE[B]:=0;
      FOR I:=0 TO LCHAIN DO WITH CHAIN[I] DO
      BEGIN IF SENTINELTEST(I,I) THEN
            BEGIN NRES:=NRES+1;SURFACE:=SURFACE+ACCESS;
                  FOR J:=1 TO 2 DO IF DONOR[J].ENERGY<HBHIGH THEN
                  BEGIN NHBOND:=NHBOND+1;K:=DONOR[J].RESIDUE-I;
                        IF ABS(K)<6 THEN
                        NHBTURN[K]:=NHBTURN[K]+1;
            END   END   ELSE NCHAIN:=NCHAIN+1;
            IF SS[SYMBOL]='H' THEN LHELIX:=LHELIX+1 ELSE IF LHELIX>0 THEN
            BEGIN IF LHELIX>MAXHIST THEN LHELIX:=MAXHIST;
                  HELIXHIST[LHELIX]:=HELIXHIST[LHELIX]+1;LHELIX:=0;
      END;  END;
      IF NBRIDGE>0 THEN FOR I:=1 TO NBRIDGE DO WITH BRIDGETABLE[I] DO
      BEGIN HBRIDGE[BTYP]:=HBRIDGE[BTYP]+(IE-IB)+2; IF FROM=0 THEN
            BEGIN J:=I;K:=0;
                  REPEAT K:=K+BRIDGETABLE[J].IE-BRIDGETABLE[J].IB+1;
                         J:=BRIDGETABLE[J].TOWARDS
                  UNTIL  J=0;IF K>MAXHIST THEN K:=MAXHIST;
                  BETAHIST[BTYP][K]:=BETAHIST[BTYP][K]+1;
      END;  END;  IF NBRIDGE>0 THEN
      BEGIN LADDERSET:=[];FOR I:=1 TO NBRIDGE DO LADDERSET:=LADDERSET+[I];
            FOR I:=1 TO NBRIDGE DO WITH BRIDGETABLE[I] DO
            IF (FROM=0)AND(I IN LADDERSET) THEN
            BEGIN IF ([I]<>LINKSET)OR(IE>IB) THEN
                  BEGIN K:=0;FOR J:=1 TO NBRIDGE DO
                        IF (BRIDGETABLE[J].FROM=0)AND(J IN LINKSET) THEN
                        K:=K+1;SHEETHIST[K]:=SHEETHIST[K]+1;
                  END;  LADDERSET:=LADDERSET-LINKSET;
      END;  END;
      WRITELN(TAPEOUT,NRES:5,NCHAIN:3,(NSSINTER+NSSINTRA):3,NSSINTRA:3,
      NSSINTER:3,' TOTAL NUMBER OF RESIDUES, NUMBER OF CHAINS, ',
      'NUMBER OF SS-BRIDGES(TOTAL,INTRACHAIN,INTERCHAIN)',
      '                .');
      WRITELN(TAPEOUT,SURFACE:8:1,'   ACCESSIBLE SURFACE OF',
      ' PROTEIN (ANGSTROM**2)                                 ',
      '                                        .');
      WRITELN(TAPEOUT,NHBOND:5,(100.0*NHBOND/NRES):5:1,
      '   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(J)  , ',
      'SAME NUMBER PER 100 RESIDUES                              .');
      I:=HBRIDGE[PARALLEL];J:=HBRIDGE[ANTIPARALLEL];
      WRITELN(TAPEOUT,I:5,(100.0*I/NRES):5:1,
      '   TOTAL NUMBER OF HYDROGEN BONDS IN     PARALLEL BRIDGES, ',
      'SAME NUMBER PER 100 RESIDUES                              .');
      WRITELN(TAPEOUT,J:5,(100.0*J/NRES):5:1,
      '   TOTAL NUMBER OF HYDROGEN BONDS IN ANTIPARALLEL BRIDGES, ',
      'SAME NUMBER PER 100 RESIDUES                              .');
      FOR I:=-5 TO 5 DO
      BEGIN IF I<0 THEN CC:='-' ELSE CC:='+';K:=ABS(I);
            WRITELN(TAPEOUT,NHBTURN[I]:5,(100.0*NHBTURN[I]/NRES):5:1,
            '   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I',
            CC,K:1,'), ',
      'SAME NUMBER PER 100 RESIDUES                              .');
      END;  FOR I:=1 TO MAXHIST DO WRITE(TAPEOUT,I:3);
      WRITELN(TAPEOUT,'     *** HISTOGRAMS OF ***           .');
      FOR I:=1 TO MAXHIST DO WRITE(TAPEOUT,HELIXHIST[I]:3);
      WRITELN(TAPEOUT,'    RESIDUES PER ALPHA HELIX         .');
      FOR I:=1 TO MAXHIST DO WRITE(TAPEOUT,BETAHIST[PARALLEL][I]:3);
      WRITELN(TAPEOUT,'    PARALLEL BRIDGES PER LADDER      .');
      FOR I:=1 TO MAXHIST DO WRITE(TAPEOUT,BETAHIST[ANTIPARALLEL][I]:3);
      WRITELN(TAPEOUT,'    ANTIPARALLEL BRIDGES PER LADDER  .');
      FOR I:=1 TO MAXHIST DO WRITE(TAPEOUT,SHEETHIST[I]:3);
      WRITELN(TAPEOUT,'    LADDERS PER SHEET                .');
END;  (* STATISTICS *)
PROCEDURE WRITEHB(I:INTEGER;HB:HYDROGENBOND);
VAR   E:REAL;
BEGIN WITH HB DO
      BEGIN IF RESIDUE<>0 THEN RESIDUE:=RESIDUE-I;E:=ENERGY/1000.0;
            WRITE(TAPEOUT,RESIDUE:4,',',E:4:1);
END;  END;(* WRITEHB *)
BEGIN STATISTICS;WRITELN(TAPEOUT,
      '  #  RESIDUE AA STRUCTURE BP1 BP2  ACC   N-H-->O  O-->H-N ',
             ' N-H-->O  O-->H-N    TCO  KAPPA ALPHA  PHI   PSI    ',
             'X-CA   Y-CA   Z-CA ');
      FOR I:=1 TO LCHAIN DO WITH CHAIN[I] DO
      BEGIN WRITE(TAPEOUT,I:5,' ');FOR J:=1 TO 6 DO
	BEGIN WRITE(MINI,AAIDENT[J]);
            WRITE(TAPEOUT,AAIDENT[J]) END;
            WRITE(TAPEOUT,' ',AA,'  ',SS[SYMBOL],' ');
	    WRITE(MINI,' ',AA,' ',SS[SYMBOL],' ');
            FOR S:=TURN3 TO BETA2 DO BEGIN WRITE(TAPEOUT,SS[S]);
	    WRITE(MINI,SS[S])
	    END;
            FOR S:=BETA1 TO BETA2 DO BEGIN WRITE(TAPEOUT,PARTNER[S]:4);
	    WRITE(MINI,PARTNER[S]:4) END;
	    WRITE(MINI,SHEETLABEL,ACCESS:4,' ');
            WRITE(TAPEOUT,SHEETLABEL,ACCESS:4,' ');FOR J:=1 TO 2 DO
            BEGIN WRITEHB(I,ACCEPTOR[J]);WRITEHB(I,DONOR[J]) END;
            PHI:=360.0;PSI:=360.0;TCO:=0.0;
            IF SENTINELTEST(I-1,I) THEN
            BEGIN PHI:=DIHEDRALANGLE(CHAIN[I-1].C,N,CA,C);
                  TCO:=COSANGLE(C,O,CHAIN[I-1].C,CHAIN[I-1].O);
            END;  IF SENTINELTEST(I,I+1) THEN
            PSI:=DIHEDRALANGLE(N,CA,C,CHAIN[I+1].N);
            WRITELN(TAPEOUT,TCO:8:3,KAPPA:6:1,ALPHA:6:1,PHI:6:1,PSI:6:1,
                            CA[1]:7:1,CA[2]:7:1,CA[3]:7:1);
	    WRITELN(MINI);
END;  END; (* PRINTOUT *)
(*----------------------------------------------------------------------*)
(*----------------------------------------------------------------------*)
BEGIN WRITELN('Program CHRIS');
WRITELN('Secondary Structure definition program of');
WRITELN('Kabasch and Sander');WRITELN('VAX version 3');
WRITELN('Any problems see D.J.B.');
WRITELN; WRITELN('Input filename ?:');
READLN(DSNAME);
WRITELN('Full Output filename ?:');
READLN(DSNAME2);
WRITELN('.SSS (Mini-Output) filename ?:');
READLN(DSNAME3);
OPEN(TAPEIN,FILE_NAME:=DSNAME,HISTORY:=READONLY);
OPEN(TAPEOUT,FILE_NAME:=DSNAME2,HISTORY:=NEW);
OPEN(MINI,FILE_NAME:=DSNAME3,HISTORY:=NEW);
RESET(TAPEIN); REWRITE(TAPEOUT); REWRITE(MINI);
      LCHAIN:=0;INPUTCOORDINATES(LCHAIN);
      IF NOT SENTINELTEST(1,LCHAIN) THEN
      WRITELN(' !!! POLYPEPTIDE CHAIN INTERRUPTED !!!');
      WRITELN('INPUTCOORDINATES DONE',LCHAIN);
      FLAGSSBONDS; WRITELN('FLAGSSBONDS DONE');
      FLAGCHIRALITY;     WRITELN('FLAGCHIRALITY DONE');
      FLAGHYDROGENBONDS; WRITELN('FLAGHYDROGENBONDS DONE');
      FLAGBRIDGE;        WRITELN('FLAGBRIDGE DONE');
      FLAGTURN;          WRITELN('FLAGTURN DONE');
      WRITELN(OUTPUT,'Accessibility calcs. can be done if');
      WRITELN(OUTPUT,'you wish but they take a long time !!!');
      WRITELN('Do you want accessiblity calcs. done (Y/N) ?:');
      READLN(INPUT,REPLY);
      IF REPLY = 'Y' THEN BEGIN
      FLAGACCESS;        WRITELN('FLAGACCESS DONE') END;
      PRINTOUT;          WRITELN('PRINTOUT DONE');
99:; (* ERROR EXIT *)
END.
