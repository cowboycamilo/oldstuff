/* *** This file is automatically generated by dimensions.sh from a ***
   *** dimension-independent file.  Edit at your peril.             *** */


#ifndef _p_grid2_h
#define _p_grid2_h

/*

p_grid implements a parallel grid: basically a more useful XArray

*/

#include <string.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <math.h>
#include "kelp.h"
#include "s_grid2.h"
#include "XArray2.h"
#include "VectorMover2.h"
#include "GhostPlan2.h"
#include "GhostIterator2.h"

class p_grid2: public XArray2<s_grid2>
{
   Point2 _ghost;	/* ghost cell vector			*/
   static int debug_counter;
public:
   MotionPlan2 fg_plan;	/* fill ghost region motionplan		*/
public:
   p_grid2(); 
   p_grid2(const FloorPlan2& F, const int build_fgp = TRUE);
   p_grid2(const GhostPlan2& F, const int build_fgp = TRUE);
   p_grid2(const p_grid2& IG, const int build_fgp = TRUE);
   ~p_grid2();

   virtual void instantiate(const FloorPlan2& F, const int build_fgp = TRUE);
   virtual void instantiate(const GhostPlan2& F, const int build_fgp = TRUE);
   virtual void instantiate(const p_grid2& IG, const int build_fgp = TRUE);
   virtual void build_fg_plan();

   const Point2& ghost() const {return _ghost;			}
   int ghost(const int dim) const {return _ghost(dim);		}

   Region2 interior(const int i)
   { return(grow((*this)(i).region(),-ghost()));		}

   void negate();
   void fill(const double v);
   void assign_ghost(const double v);
   void fill_ghost();
   void copy_on_intersect(p_grid2 &G);
   void CopyOnIntersection(p_grid2 &G);
   void copy(p_grid2& G);
   void copy(p_grid2& G, const FloorPlan2& F);
   void copy_grid(p_grid2& from_grid, int from_index, int to_index);
   void add_on_intersect(p_grid2 &G);
   void add_grid(p_grid2& from_grid, int from_index, int to_index);
   void plus(p_grid2& G);
   void plus_all(p_grid2& G);
   void minus(p_grid2& G);
   void mult(double s);
   double norm(int p);

   void debug_print(char *name);
};

#endif
